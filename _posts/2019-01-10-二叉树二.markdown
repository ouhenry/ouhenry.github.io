**什么是堆**

>优先队列（Priority Queue）:特殊的“队列”，取出元素的顺序是依照元素的优先权（关键字）大小，而不是元素进入队列的先后顺序。

**堆的两个特性**

- 机构性：用数组表示的完全二叉树；
- 有序性：任一节点的关键字是其子树所有节点的最大值（或最小值）

	1.“最大堆（MaxHeap)”,也称"大顶堆"：最大值
	2.“最小堆（MinHeap）”,也称"小顶堆"：最小值



**最大堆**

- MaxHeap Creat(int MaxSize)：创建一个空的最大堆。
- Boolean IsFull(MaxHeap H): 判断最大堆H是否已满。
- Insert(MaxHeap H, ElementType item): 将元素item插入最大堆H。
- Boolean IsEmpty(MaxHeap H):判断最大堆H是否为空。
- ElementType DeleteMax(MaxHeap H):返回H中最大元素（高优先级）

**定义堆**

	typedef struct HNode *Heap; /* 堆的类型定义 */
	struct HNode {
    	ElementType *Data; /* 存储元素的数组 */
    	int Size;          /* 堆中当前元素个数 */
    	int Capacity;      /* 堆的最大容量 */
	};
	typedef Heap MaxHeap; /* 最大堆 */
	typedef Heap MinHeap; /* 最小堆 */
 
define MAXDATA 1000  /* 该值应根据具体情况定义为大于堆中所有可能元素的值 */

**创建堆**

	MaxHeap CreateHeap( int MaxSize )
	{ /* 创建容量为MaxSize的空的最大堆 */
 
    	MaxHeap H = (MaxHeap)malloc(sizeof(struct HNode));
    	H->Data = (ElementType *)malloc((MaxSize+1)*sizeof(ElementType));
    	H->Size = 0;
    	H->Capacity = MaxSize;
    	H->Data[0] = MAXDATA; /* 定义"哨兵"为大于堆中所有可能元素的值*/
 
    	return H;
	}

**判断堆是否已满**

	bool IsFull( MaxHeap H )
	{
    	return (H->Size == H->Capacity);
	}

**插入**

	bool Insert( MaxHeap H, ElementType X )
	{ /* 将元素X插入最大堆H，其中H->Data[0]已经定义为哨兵 */
    	int i;
  
    	if ( IsFull(H) ) { 
        	printf("最大堆已满");
        	return false;
    	}
    	i = ++H->Size; /* i指向插入后堆中的最后一个元素的位置 */
    	for ( ; H->Data[i/2] < X; i/=2 )
        	H->Data[i] = H->Data[i/2]; /* 上滤X */
    	H->Data[i] = X; /* 将X插入 */
    	return true;
	}
 
define ERROR -1 /* 错误标识应根据具体情况定义为堆中不可能出现的元素值 */

**判断是否为空**

	bool IsEmpty( MaxHeap H )
	{
    	return (H->Size == 0);
	}

**删除**

	ElementType DeleteMax( MaxHeap H )
	{ /* 从最大堆H中取出键值为最大的元素，并删除一个结点 */
    	int Parent, Child;
    	ElementType MaxItem, X;
 
    	if ( IsEmpty(H) ) {
        	printf("最大堆已为空");
        	return ERROR;
    	}
 
    	MaxItem = H->Data[1]; /* 取出根结点存放的最大值 */
    	/* 用最大堆中最后一个元素从根结点开始向上过滤下层结点 */
    	X = H->Data[H->Size--]; /* 注意当前堆的规模要减小 */
    	for( Parent=1; Parent*2<=H->Size; Parent=Child ) {
        	Child = Parent * 2;
        	if( (Child!=H->Size) && (H->Data[Child]<H->Data[Child+1]) )
            	Child++;  /* Child指向左右子结点的较大者 */
        	if( X >= H->Data[Child] ) break; /* 找到了合适位置 */
        	else  /* 下滤X */
            	H->Data[Parent] = H->Data[Child];
    	}
    	H->Data[Parent] = X;
 
    	return MaxItem;
	} 

**建造最大堆**

- 方法1：通过插入操作，将N个元素一个一个相继插入到一个初始为空的堆中去，其时间代价最大为O（N logN）
- 方法2：在线性时间复杂度下建立最大堆。
1）将N个元素按输入顺序存入，先满足完全二叉树的结构特性。（2）调整各结点位置，以满足最大对的有序特性。


方法2实现：

	void PercDown( MaxHeap H, int p )
	{ /* 下滤：将H中以H->Data[p]为根的子堆调整为最大堆 */
    	int Parent, Child;
    	ElementType X;
 
    	X = H->Data[p]; /* 取出根结点存放的值 */
    	for( Parent=p; Parent*2<=H->Size; Parent=Child ) {
        	Child = Parent * 2;
        	if( (Child!=H->Size) && (H->Data[Child]<H->Data[Child+1]) )
            	Child++;  /* Child指向左右子结点的较大者 */
        	if( X >= H->Data[Child] ) break; /* 找到了合适位置 */
        	else  /* 下滤X */
            	H->Data[Parent] = H->Data[Child];
    	}
    	H->Data[Parent] = X;
	}
 

	void BuildHeap( MaxHeap H )
	{ /* 调整H->Data[]中的元素，使满足最大堆的有序性  */
  	/* 这里假设所有H->Size个元素已经存在H->Data[]中 */
 
    	int i;
 
    	/* 从最后一个结点的父节点开始，到根结点1 */
    	for( i = H->Size/2; i>0; i-- )
        	PercDown( H, i );
	}